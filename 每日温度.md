### 题目
根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

### 思路
该题有两个思路：   
1、第一个是从左到右遍历，然后每个元素再依次从当前位置向右遍历，这样经过两轮遍历后，肯定可以得到题目要求的数组。但是该方案有点耗时，所以我们要考虑如何减少耗时。目前来看，只能通过减少第二轮的遍历次数来解决   
2、第二个就是使用一个递减栈去做，每次将栈顶元素和当前元素进行比较，如果栈顶元素大于当前元素，则将当前元素压入栈内，并且将栈顶元素的位置 - 当前元素位置得到的结果放入结果数组中；而如果栈顶元素不大于当前元素，则将栈顶元素弹出，继续比较栈顶元素和当前元素，直到栈为空，那么则将0写入结果数组，并且将当前元素压栈   
（本来插入结果数组想用array_unshift来减少数组反转或排序的耗时，结果直接超限了，上网查了查，原来array_unshift每次都会新创建一个数组，将新元素插入后，才会插入原数组内容，所以更耗时了。。。所以对于php这种只能最后靠排序保持和原数组一样的顺序的问题，我只能说垃圾php~）

### 解法
```php
class Solution {

    /**
     * @param Integer[] $T
     * @return Integer[]
     */
    function dailyTemperatures($T) {
        $count = count($T);
        //存放新生成的距离最近的比当前温度高的天数的数组
        $arr = [];
        //准备一个递减栈
        $stack = [];
        for($i = $count - 1; $i >= 0; $i--){
            $stackCount = count($stack);
            //直到栈空为止，找到栈中比当前元素大的元素，该元素就是正序遍历时最优先比当前气温大的那一天
            while(!empty($stack)){
                if($T[$stack[$stackCount - 1]] <= $T[$i]){
                    array_pop($stack);
                    $stackCount--;
                }else{
                    //找到后，把当前的元素c也压入栈内，因为比该元素c更之前的元素a如果找比自己更大的且最近的就是要压入的这个元素c了，因为当前元素c后面的就算有比当前元素c小比元素a大，但是相对于c来说，距离a更远
                    array_push($stack, $i);
                    break;
                }
            }
            if(empty($stack)){
                //当然遍历空了也得压栈，因为没有比它更大了，并且把数组当前位置标记为0
                array_push($stack, $i);
                $arr[$i] = 0;
            }else{
                //把数组当前位置标记为找到最近的更大的元素距离 - 当前元素距离
                $arr[$i] = $stack[$stackCount - 1] - $i;
            }
        }
        ksort($arr);
        //$arr = array_reverse($arr);
        return $arr;
    }
}
```
